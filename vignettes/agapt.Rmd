---
title: "AGA Pseudotime"
date: "`r Sys.Date()`"
output: github_document
editor_options: 
  chunk_output_type: console
---

```{r eval=FALSE, include=FALSE}
file <- "agapt"
rmarkdown::render(glue::glue("vignettes/{file}.Rmd"), output_dir = "inst/doc/")
readr::read_lines(glue::glue("inst/doc/{file}.md")) %>% stringr::str_replace_all(paste0(rprojroot::find_rstudio_root_file(), "/inst/doc/"), "") %>% readr::write_lines(glue::glue("inst/doc/{file}.md"))
```

This document serves to provide insight into how a trajectory inference method was used and wrapped. 
Feel free to discuss implementation-specific details by [creating an issue](https://github.com/dynverse/dynmethods/issues) on GitHub,
or improve the wrapper and create a pull request.


```{r}
library(tidyverse)
library(dynmethods)
library(dynwrap)
library(dynutils)
library(dynplot)
```

# Description
AGA Pseudotime is similar to the [AGA wrapper](aga.md), except that a start cell has to be given, and the method produces a 
more refined pseudotemporal ordering of each cell.
The core algorithms used are k-nearest-neighbours for representing cells as a graph, louvain clustering for grouping 
cells into milestones, connectivity testing for identifying transitions between the milestones, and random walks for determining 
the pseudotemporal ordering of the cells.
The wrapper can be accessed using the `description_agapt` function.
```{r}
method <- description_agapt()
```

This description contains information on which packages need to have been installed in order to run 
the method and what are the parameters.

```{r}
str(method, max.level = 1)
method$par_set
```

# Example
First we retrieve a toy dataset from [http://github.com/dynverse/dyntoy](dyntoy).
```{r}
toy_tasks <- dyntoy::toy_tasks %>% 
  filter(model == "consecutive_bifurcating") %>% 
  slice(1)
toy_task <- toy_tasks %>% extract_row_to_list(1)

plot_default(toy_task)
```

We extract the default parameters from the method.
```{r}
defprm <- get_default_parameters(method)
```

Applying AGA on the toy dataset can be performed using the `execute_method` function.
```{r}
out <- execute_method(toy_tasks, method, parameters = defprm)[[1]]
```

The output will consist of a summary and the model. The summary will contain information 
pertaining the execution of the method, while the model will contain the trajectory inferred
by the method.

```{r}
out$summary %>% knitr::kable()

model <- out$model 

plot_default(model)
plot_trajectory(model, method)
```

# Wrapper implementation
This section will detail the specific wrapper implementation by applying it on the toy dataset, 
and should follow the same implementation structure as the [https://github.com/dynverse/dynmethods/blob/master/R/ti_agapt.R](source code).

Since AGA is implemented in Python, we created an R package for it, available at [github.com/dynverse/aga](https://github.com/dynverse/aga).
The R package will write the expression values and any parameters to a file, execute a python script, and read the results from output files produced by AGA.
```{r}
expression <- toy_task$expression

start_cell <- sample(toy_task$prior_information$start_cells, 1)

aga_out <- aga::aga(
  expression = expression,
  start_cell = start_cell,
  grouping_assignment = NULL,
  n_neighbours = defprm$n_neighbours,
  n_pcs = defprm$n_pcs,
  n_dcs = defprm$n_dcs,
  resolution = defprm$resolution,
  tree_based_confidence = defprm$tree_based_confidence,
  verbose = FALSE,
  num_cores = 1
)
aga_out$obs <- aga_out$obs %>% mutate(group_id = paste0("B", group_id))
aga_out$adj <- aga_out$adj %>% mutate(from = paste0("B", from), to = paste0("B", to))

branch_ids <- unique(c(aga_out$adj$from, aga_out$adj$to, aga_out$obs$group_id))
```


After building a kNN graph, the kNN graph is clustered into louvain groups. 
Each cluster is considered a separate branch, on which cells are pseudotemporally ordered.
```{r}
aga_out$obs %>% head(6) %>% knitr::kable()
```

Several tests are used to assess which transitions exist between the louvain groups. 
We use the `aga_adjacency_tree_confidence` to determine how the branches are connected.
```{r}
aga_out$adj %>% head(6) %>% knitr::kable()

branch_network <- aga_out$adj %>%
  mutate_at(vars(from, to), as.character) %>%
  filter(aga_adjacency_tree_confidence > 0) %>%
  select(from, to)
knitr::kable(branch_network)
```

We transform the network according to the distance it has from the starting cell.
```{r}

# determine order of branches, based on location of root cell
branch_graph <- igraph::graph_from_data_frame(branch_network, directed = FALSE, vertices = branch_ids)
branch_order <- 
  branch_graph %>% 
  igraph::dfs(aga_out$obs %>% filter(cell_id == start_cell) %>% pull(group_id)) %>%
  .$order %>% 
  names()

# now flip order of branch network if from branch is later than to branch
branch_network <- branch_network %>%
  mutate(from_original = from, to_original = to) %>%
  mutate(flip = map2(from, to, ~diff(match(c(.x, .y), branch_order)) < 0)) %>%
  mutate(
    from = ifelse(flip, to_original, from_original),
    to = ifelse(flip, from_original, to_original)
  ) %>%
  select(from, to)
knitr::kable(branch_network)
```


Now we create milestone network by giving each branch an edge, and adding a zero-length edge between each branch
```{r}
milestone_network <- bind_rows(
  tibble(
    from = paste0(branch_ids, "_from"),
    to = paste0(branch_ids, "_to"),
    length = 1,
    directed = TRUE
  ),
  mutate(
    branch_network, 
    from = paste0(from, "_to"),
    to = paste0(to, "_from"),
    length = 0,
    directed = TRUE
  )
)
```

We place each cell along an edge of the milestone network:
```{r}
milestone_ids <- unlist(map(branch_ids, ~ paste0(., c("_from", "_to"))))

progressions <- aga_out$obs %>%
  mutate(from = paste0(group_id, "_from"), to = paste0(group_id, "_to")) %>%
  group_by(group_id) %>%
  mutate(percentage = dynutils::scale_minmax(aga_pseudotime)) %>%
  ungroup() %>%
  select(cell_id, from, to, percentage)
```


The prediction is wrapped using the `add_trajectory_to_wrapper` function. 
```{r}
prediction <- 
  wrap_prediction_model(
    cell_ids = rownames(expression)
  ) %>% add_trajectory_to_wrapper(
    milestone_ids = milestone_ids,
    milestone_network = milestone_network,
    progressions = progressions,
    divergence_regions = NULL,
    aga_out = aga_out
  ) 

plot_default(prediction)
plot_trajectory(model, method)
```

# Quality control
TODO

# To do's
 * Remove zero edges from the branch network
 * Allow the aga R package to return the dimensionality reductions created by scanpy.
